---
layout: post
title:  "Enhancing an Order Book System"
date:   2023-09-19 11:01:43 -0700
categories: rust trading 
---


## Introduction:
In the world of high-frequency trading and financial systems, precision and reliability are paramount. A small error in calculations can lead to significant financial losses. Today, we revisit a project where we took an existing order book implementation and made key improvements to enhance its performance and precision. The original order book implementation was forked from dgtony's project, and we are grateful for the foundation he provided.

## Transition from Sequential IDs to GUIDs
One of the critical changes we introduced to the order book system was the replacement of sequential order IDs with Globally Unique Identifiers (GUIDs). While sequential IDs work well for simple applications with a single database, they pose challenges in more complex, production-level environments where multiple databases are involved, especially in high-frequency trading platforms.

## The Need for GUIDs
GUIDs ensure that each order has a globally unique identifier, even when distributed across multiple databases. This uniqueness is crucial in preventing conflicts and ensuring the integrity of the order book. By switching to GUIDs, we made the order book system more robust and suitable for high-frequency trading.

##Precision Matters: Transitioning to BigDecimals
The second significant change we made to the original implementation was replacing floating-point numbers with BigDecimal for all numerical calculations. This transition was motivated by the need to eliminate floating-point rounding errors that could potentially lead to inaccuracies in financial computations.

##The Problem with Floating-Point Numbers
Floating-point numbers, such as f64, are inherently imprecise when it comes to decimal arithmetic. They are susceptible to rounding errors, which can accumulate over time and result in significant discrepancies in financial calculations.

##The Precision of BigDecimal
BigDecimal, on the other hand, provides precise decimal arithmetic. It allows us to work with decimal numbers without the risk of rounding errors. In the context of an order book system, where financial transactions and calculations are frequent and critical, BigDecimal ensures accuracy and reliability.

##Demonstrating Floating-Point Error
To illustrate the difference between using floating-point numbers and BigDecimal, consider the following Rust code snippet:

```
let x = 0.1_f64;
let y = 0.2_f64;
let z = x + y;

println!("x: {}", x);
println!("y: {}", y);
println!("x + y: {}", z);

if z == 0.3_f64 {
    println!("z is equal to 0.3");
} else {
    println!("z is not equal to 0.3");
}
```

Output:
x: 0.1
y: 0.2
x + y: 0.30000000000000004
z is not equal to 0.3

As demonstrated in the output, even a seemingly simple addition of 0.1 and 0.2 using floating-point numbers results in a value slightly off from the expected 0.3. This discrepancy can lead to significant issues in financial systems, highlighting the importance of using BigDecimal for precise calculations.

Conclusion
In revisiting our order book project, we've shown how small but critical changes can greatly improve the reliability and precision of a financial system. By transitioning from sequential order IDs to GUIDs and replacing floating-point numbers with BigDecimal, we've made the system more robust and accurate, particularly in high-frequency trading environments.

For the full source code of our enhanced order book system, please visit our GitHub repository: https://github.com/flomang/paper/tree/main/orderbook

In the fast-paced world of finance, attention to detail and precision is key, and these improvements ensure that our order book system meets these standards, providing a solid foundation for further development and application in real-world financial systems. Cheers to progress and innovation!